/* trashcan.c */
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE      1024
#define PATHSIZE     256
#define TRASHFOLDER  "ti3_trash"

char copy_buffer[BUFSIZE];

/* "copy" kopiert den Dateiinhalt einer Datei namens "source". Eine Kopie target
 * wird nur erzeugt, wenn eine Datei "target" noch nicht existiert. Die
 * Zugriffsrechte werden nicht kopiert, sondern auf "rwx --- ---" gesetzt.
 * RETURNS 0 in case of success, -1 if source file could not be found */
int copy(char *source, char *target) {
  int in, out, count;
  if((in = open(source, O_RDONLY)) == -1)
    return -1;
  if ((out = open(target, O_WRONLY | O_EXCL | O_CREAT, 0700)) == -1)
    return -2;
  while (count = read(in, copy_buffer, BUFSIZE))
    write(out, copy_buffer, count);
  close(out); close(in);
  return 0;
}

char parse_command(char *command) {
  return command[1];
}

/* erzeugt einen Ordner foldername */
int setup_trashcan(char *foldername) {
  mkdir(foldername, O_EXCL | 0777);
}

/* fuehrt trashcan -p[ut] filename aus */
int put_file(char *foldername, char *filename) {
  char temp[PATHSIZE]; int c_error;
  strcpy(temp, foldername);
  strcat(temp, "/");
  strcat(temp, filename);
  if((c_error = copy(filename, temp)) == 0) {
    if(unlink(filename) == -1)
      return -3;
  }
  return c_error;
}

/* führt trashcan -g[et] filename aus */
int get_file(char *foldername, char *filename) {
  char temp[PATHSIZE]; int c_error;
  strcpy(temp, foldername);
  strcat(temp, "/");
  strcat(temp, filename);
  if((c_error = copy(temp, filename)) == 0) {
    if(unlink(temp) == -1)
      return -3;
  }
  return c_error;
}

/* führt trashcan -r[emove] filename aus
 * RETURNS -1 if trash file could not be removed, 0 in case of succes */
int remove_file(char *foldername, char *filename) {
  char temp[PATHSIZE];
  strcpy(temp, foldername);
  strcat(temp, "/");
  strcat(temp, filename);
  return unlink(temp);
}

int main(int argc, char *argv[]) {
  if (argc == 1) {
    printf("...not enough arguments!\n");
    return EXIT_FAILURE;
  } else {
    setup_trashcan(TRASHFOLDER);
    char command = parse_command(argv[1]);
    switch (command) {
      case 'p':
        if (argc != 3) {
          printf("...not enough arguments!\n");
          return EXIT_FAILURE;
        }
        int p_error = put_file(TRASHFOLDER, argv[2]);
        switch (p_error) {
          case -1:
            printf("...source file not found!\n");
            break;
          case -2:
            printf("...trash file was not created!\n");
            break;
          case -3:
            printf("...source file could not be removed!\n");
          default:
            break;
        }
        break;
      case 'g':
        if (argc != 3) {
          printf("...not enough arguments!\n");
          return EXIT_FAILURE;
        }
        int g_error = get_file(TRASHFOLDER, argv[2]);
        switch (g_error) {
          case -1:
            printf("...trash file not found!\n");
            break;
          case -2:
            printf("...restore file was not created!\n");
            break;
          case -3:
            printf("...trash file could not be removed!\n");
          default:
            break;
        }
        break;
      case 'r':
        if (argc != 3) {
          printf("...not enough arguments!\n");
          return EXIT_FAILURE;
        }
        int r_error = remove_file(TRASHFOLDER, argv[2]);
        if (r_error)
          printf("...trash file could not be removed!\n");
        break;
      default:
        printf("...unknown command!\n");
        return EXIT_FAILURE;
    }
  }
  return EXIT_SUCCESS;
}
