\chapter{\"Ubung zum 27.11.2009}\label{ue5}
\section{Linux Scheduler}\label{ue5_1}
Der aktuelle Linux-Scheduler ist der Completely Fair Scheduler(CFS).\\
Das Prinzip des aktuellen Schedulers gleicht dem des Round Robin, es ist nur spezifizierter, feiner abgestimmt und beachtet gewisse Sonderf\"alle. So ist es dem Scheduler z.B. m\"oglich Sleeperprozesse zu erkennen um nicht unn\"otig Ressourcen an sie verschwenden zu m\"ussen.\\
Die Funktionsweise ist also denkbar simpel, jeder Proze\ss\ soll m\"oglichst gleichviel Bearbeitungszeit von der CPU erhalten.\\
Dies geschieht indem es, im Gegensatz zum vorherigen O(1)-Scheduler, keine runtime-queues mehr gibt, sondern ein Z\"ahler der die bisher gewartete Zeit beinhaltet(dieser ist mittels eines Rot-Schwarz-Baumes implementiert). So ist es dem Scheduler m\"oglich den Proze\ss\ zu erkennen, der als n\"achstes am ``dringendsten'' Rechenzeit ben\"otigt um wieder eine faire Verarbeitung der Prozesse zu gew\"ahrleisten, dieser Z\"ahler notiert nanosekundengenau. So wird es, je nach Proze\ss, m\"oglich ihm soviel Rechenzeit zuzuteilen das er wieder ``fair'' bearbeitet wurde und bis ein anderer Proze\ss\ wieder am meisten Zeit gewartet hat und somit am ``n\"otigsten'' bearbeitet werden muss.\\
Die Komplexizit\"atsklasse des Schedulers betr\"agt beim Einordnen eines anfallenden Prozesses O(1), ist also für jeden Proze\ss\ und bei jedweder Anzahl an anfallenden Prozessen gleich, oder ann\"ahrend gleich, und bei der Wiedereinordnung eines Prozesses betr\"agt sie O(log(n)).
Durch die Nutzung eines Z\"ahlers sind weder Heuristiken, Timeslices, Array-Switching, noch Statistiken n\"otig.
\section{Parameter für Optimierung von Scheduling Algorithmen}\label{ue5_2}
Nach folgenden Parametern lassen sich Scheduling-Algorithmen für Server- und Desktoprechner optimieren:
\begin{itemize}
 \item Bearbeitungszeit
 \item Durchlaufzeit
 \item Antwortzeit
 \item Durchsatz
 \item Fairness
\end{itemize}
\section{Scheduler im Realtime-Kernel}\label{ue5_3}
Die Funktionsweise des Schedulers im RTLinux ist dem des normalen Linux-Schedulers \"ahnlich, der einzige Unterschied ist der, dass vor dem normalen Scheduler ein Scheduler ist, der entscheidet, ob ein Proze\ss\ eine Echtzeitanfrage ist, und somit direkt bearbeitet werden muss oder ob es sich nicht um eine Echtzeitanfrage handelt und somit an den herk\"omlichen Scheduler weiter geleitet werden kann. Logischer Weise haben Echtzeitanfragen vorrang gegen\"uber herk\"omlichen Prozessen.
\section{Programmieren in C}\label{ue5_4}
\lstinputlisting[breaklines=true]{src/u5/schedulerFrame.c}