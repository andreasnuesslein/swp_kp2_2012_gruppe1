\chapter{\"Ubung zum 20.11.2009}\label{ue4}
\section{Unterschiedliche Auswirkungen externer Fragmentierung bei HDD und RAM}\label{ue4_1}
Blockieren viele verstreute kleinere Bl\"ocke gespeicherter Informationen einen großen Bereich der Festplatte bzw. des Speichers, spricht man von externer Fragmentierung. Um den zu großen Block trotzdem unterzubringen, muss er in kleinere aufgeteilt werden und fragmentiert abgelegt werden. \\
Dabei sind die Auswirkungen externer Fragmentierung bei Festplatten anders als bei RAM.\\
W\"ahrend beim RAM aufgrund schneller Zugriffszeiten kein merkbarer Unterschied besteht ob die Daten in einer Folge oder zerstückelt und überall verteilt vorliegen, ist die Auswirkung bei Festplatten gravierender.\\
Das liegt daran, dass Festplatten eine langsamere Zugriffszeit haben und das der Lesekopf Daten die in Folge sind schneller lesen kann als Bruchst\"ucke die an unterschiedlichen Stellen der Disk sind.
Externe Fragmentierung hat also bei RAM keine wirklichen Auswirkungen und bei Festplatten wirkt es sich negativ aus, da die Daten langsamer gelesen werden können.

\section{Speicherzugriffsmechanismen}\label{ue4_2}
Wir implementieren zun\"achst das beschriebene Programm, welches nach Ausgabe der Adresse der Main-Funktion in eine Endlosschleife \"ubergeht.
\lstinputlisting[breaklines=true]{src/u4/aufgabe2.c}
Beim Starten der Programme wird jeweils ein eigener Prozess gestartet mit jeweils eigenem Speicher. Trotzdem wird jedes Mal die gleiche Adresse ausgegeben.
\begin{lstlisting}[breaklines=true]
saboten@nawab:~/TI3/uebung04$ ./aufgabe2 &
[1] 14049
Address of main=134513572
saboten@nawab:~/TI3/uebung04$ ./aufgabe2 &
[2] 14050
Address of main=134513572
saboten@nawab:~/TI3/uebung04$ ./aufgabe2 &
[3] 14051
Address of main=134513572
saboten@nawab:~/TI3/uebung04$
\end{lstlisting}
Der Grund hierf\"ur ist, dass hier jeweils die virtuellen Adressen ausgegeben werden anstelle von tats\"achlichen physikalischen Adressen im Arbeitsspeicher. Die virtuellen Adressen werden von der Memory Management Unit in physikalische Hardware-Adressen \"ubersetzt. Dies geschieht heutzutage \"ublicherweise nach Seiten (feste Blockgr\"oßen, vgl. Paging). Auf diese Weise wird sichergestellt, dass die Prozesse voneinander v\"ollig isoliert operieren. \\
Das Betriebssystem h\"alt für jeden Prozess eine Page Table vor. Die Adresse besteht aus einem Teil für die Seiten-Nummer und einem für den Offset - also einer Art relativer Adresse. \\
Alternativ zum Paging gibt es das Verfahren von Segmentierung, welches anstelle von festen Block-Gr\"oßen (Seiten) variable Gr\"oßen ermöglicht. Dieses Verfahren findet jedoch kaum Verwendung.

\section{Implementierung von malloc()}\label{ue4_3}
Der Befehl malloc({x | x in Byte})  reserviert auf dem Heap (also bei dynamischer Speicherverwaltung) den angeforderten Speicher für ein Programm. Wird der angeforderte Speicher nicht mit free() wieder freigegeben, erzeugt man somit zwangsl\"aufig irgendwann einen Speicher\"uberlauf.\\
\\
\[Rechnung\] $1.000.000.000.000$ Byte = $1.000.000.000$ KByte = $1.000.000$ MByte = $1000$ GByte\\
\\
\\
Unter Linux stehen 8 GB Speicher zur Verf\"ugung, also 8192*1024*1024 Byte. Der Befehl malloc(1000000000000) reserviert allerdings 1000 GByte Speicher auf dem Heap. Kein heutzutage (18.11.2009) eingesetztes Betriebssystem (somit auch nicht Linux) kann soviel Speicher auf einmal reservieren. Wir erhalten somit einen Speicher\"uberlauf.\\
\\
Wenn statt 1000 Gbyte nur 1 GB (wahrscheinlich Tippfehler!) reserviert werden sollten, w\"are das mit dem Befehl malloc(1000000000) 3 mal m\"oglich, da 3 * 1.000.000.000 Byte < 3 * 1024 * 1024 * 1024 Byte.\\
Beim 4 Aufruf von malloc(1000000000) w\"urden wir somit einen Speicher\"uberlauf erzeugen.

\section{Programmieren in C}\label{ue4_4}
\lstinputlisting[breaklines=true]{src/u4/mm.c}
%\lstinputlisting[breaklines=true]{src/u4/mm.h}
%\lstinputlisting[breaklines=true]{src/u4/mm.c}
%\lstinputlisting[breaklines=true]{src/u4/test_mm.c}